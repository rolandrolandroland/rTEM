% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rTEM_multimersim_inhibit.R
\name{multimersim_inhibit_dev}
\alias{multimersim_inhibit_dev}
\title{Multimer Simulation with Overlying point pattern (Under developement)}
\usage{
multimersim_inhibit_dev(
  guest_pattern = NULL,
  upp_under,
  upp_over = NULL,
  perc_over = 1,
  output = "guest pattern type",
  n_guests = NA,
  min_thick = NA,
  max_thick = NA,
  ztrim = 0,
  size_fracs = c(0, 1),
  num_neighbors = 6,
  sample_method = "rank",
  exponent = 1,
  weights = c(1, 1, 1),
  probs = c(1, 0, 0, 0),
  trans_plane = c("x", "y"),
  trans_frac = 0.5,
  intensity_upp_under = NA,
  intensity_upp_over = NA,
  preprocessed = FALSE,
  seed = 1
)
}
\arguments{
\item{guest_pattern}{point pattern of class \emph{ppp} or \emph{pp3}.  The final multtimer
pattern will match this pattern in class, intensity, and domain.  If this is left as NULL, then
the domain will match that of \emph{upp}, will be of the class specified in \emph{output},
and have number of guests specified in \emph{n_guest}}

\item{output}{leave as \emph{"guest pattern type"} if specifying \emph{guest_pattern}.  Otherwise, set to \emph{"ppp"} for
2D output or \emph{pp3} for 3D output}

\item{n_guests}{leave as \emph{NA} if specifying \emph{guest_pattern}. Otherwise, set to
integer for number of guests in multimer pattern}

\item{min_thick}{if \emph{guest_pattern} is 2d (ppp) and \emph{upp} is 3d (pp3) this
determines the smallest z value to keep before collapsing into 2d.}

\item{max_thick}{if \emph{guest_pattern} is 2d (ppp) and \emph{upp} is 3d (pp3) this
determines the largest z value to keep before collapsing into 2d.}

\item{ztrim}{a numeric.  This will trim this amount from both top and bottom (positive and negative z)
after multimers are generated and before pp3 pattern is collapsed into ppp.
Only applies if \emph{upp} is 3D (\emph{pp3})}

\item{size_fracs}{= a vector of numerics.  This will be the fraction of all guest points that are
assigned to groups of each size.  For example, if \emph{size_fracs = c(0.2, 0.3, 0.1, 0.4)},
 then 20\% of guests will be randomly assigned, 30\% will be in dimers, 10\% will be in trimers,
 and 30\% will be quadramers (group of 4)}

\item{num_neighbors}{An integer.  Number of nearest neighbors to select from when
forming dimers, trimers, etc..  Must be at least at least one less than the length of \emph{size_fracs}}

\item{sample_method}{if equal to \emph{"rank"}, the probability of a point of rank \emph{x}
being chosen as a guest is \emph{probs[x]}.  If equal to  \emph{"exp"},
the probability of a point of rank \emph{x} being chosen
 as a guest is \emph{probs[x] * exp(-exponent * distances[ranks]))}}

\item{exponent}{a numeric. If \emph{sample_method = "exp"}, then
this is the value of \emph{exponent} in \emph{exp(-exponent * distances[ranks])}}

\item{weights}{vector of length equal to number of dimensions in \emph{upp}. the weighted distance to each of \emph{num_neighbors} nearest neighbors
is calculated using \eqn{\sqrt{w_1 x^2 + w_2 y^2 + w_3 z^2}},
 where \emph{weights} = (\eqn{w_1, w_2, w_3}). Set to \emph{c(1, 1, 0)} for vertical dimers.}

\item{probs}{vector of probabilities.
For \eqn{probs = c(p_1, p_2, p_3, p_4)}, the probability of the first NN being
selected in \eqn{p_1}, the probability of the second is \eqn{p_2}, and so on
 @param trans_plane plane for translating
 @param trans_frac fraction of distance in plane `trans_plane` to reduce distance by
marks are assigned. Leave as \emph{NA} to use \emph{upp} as it is}

\item{upp}{point pattern of class \emph{ppp} or \emph{pp3} to use as underlying point pattern.
Multimers will be selected from these points.}
}
\description{
Under construction. See \code{\link{multimersim}} for stable version.
 Simulates multimers (groups of two/dimers, three/trimers, etc.) in
underlying point pattern (upp) to match domain and number of points in \emph{guest_pattern}.
}
\details{
Algorithm steps: Case 1: 2D Guest pattern, 3D UPP
 \itemize{
 \item{Step 1: Prechecks.  If no guest pattern is used, are both `n_guests` and `output`
 explicitly defined?  Is `n_guests` smaller than number of points in the `upp`?  If there are fewer
 probabilities than the number of neighbors to be cosidered (`num_neighbors`) then append 0's
 onto the  `probs` vector until it is long enough.  Normalize the `size_fracs` vector so that
 it sums to 1. Rescale `upp` so that it has an intensity of `intensity_upp`, unless such is left as `NA`}
 \item{Step 2:} {Select points in the scaled \emph{upp} that are
 inside the x-y limits of \emph{guest_pattern} and the z limits difined by `min_thick` and `max_thick`
 (default values are z limits of `upp`) }
 \item{Step 3:} {Determine total number of guests to be assigned.
 We will scale the number of guests either in the given `guest_pattern` or `n_guests`
 by the difference in volumes between the trimmed and untrimmed patterns.  Therefore, say `guest_pattern`
 has 1,000 points, `min_thick = 0`, `max_thick = 40`, and `ztrim = 10`, `n_points` will be
 increased to 1,000 * (40-0)/(30-10) = 2,000.  This way, after the trimming, about 1,000 guest points
 will remain
 (for dimers, this is number of guests / 2)
 and assign this many points in the scaled subsetted UPP to be guests.
  These are the "centroids"}
  \item{Step 4:} {Determine the number of groups of each size.  The number of points in groups of
  each size is simply the input variable `size_fracs`.  So We can divide this by the number of points
  in such a group size (1 for monomers, 2 for dimers, 3 for trimers, etc), and multiply by the
  total number of guest points}
  \item{Step 5:} {Randomly relabel the scaled, subsetted UPP
  so that there is one point labeled guest type for each group and the rest are labeled host type.}
  \item{Step 6:} {Randomly sample from the guest type points chosen in Step 5
  a number of points equal to the number of groups that need to have two or more points}
  \item{Step 7:} {Use \code{\link{create_groups}} to make one NN of each point chosen in Step 6
  guest type.  NN's are selected only in points from points assigned as hosts in Step 5.}
  \item{Step 8:} {Repeat Steps 6 and 7 for trimers, quadramers, etc.}
  \item{Step 9:} {Filter out all guest type points chosen in Steps 5-8 that all within `ztrim` units
  of the top (+z) or bottom (-z)}
  \item{Step 10:} {Create a 2D point pattern (class `ppp`) by ignoring the z coordinates
  of each point.  Label guest type points "G" and host type points "H"}}
Case 2: 2D Guest pattern, 2D UPP
\itemize{
\item{} {Same as steps for Case 1, except ignore Step 2, Step 3, and Step 9.}
}
Case 3: 3D Guest pattern, 3D UPP
\itemize{
\item{} {This will be the same as Case 1, except in Step 10 create a 3D point pattern (class `pp3`)
instead of a 2D point pattern}
}
}
